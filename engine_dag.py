#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Formula DAG Module
-----------------
Powered by Renoir
Created by igor.goncalves@renoirgroup.com

This module builds a Directed Acyclic Graph (DAG) to define the execution order
of formulas based on their dependencies.

The module uses the data format produced by formula_parser.py, which contains
the dependencies of each formula under the 'parsed.dag_paths' property.

Formulas are ordered so that dependencies are executed first, ensuring that all
variables are available when needed during calculation.
"""

import json
import networkx as nx
import logging
from typing import Dict, List, Any, Union

# Initialize logger for this module
logger = logging.getLogger("formulas_dag")

# Configure logging level if not already configured elsewhere
if not logger.handlers:
    logger.setLevel(logging.INFO)
    handler = logging.StreamHandler()
    formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    handler.setFormatter(formatter)
    logger.addHandler(handler)

def build_formula_dag(json_data: Union[str, List]) -> nx.DiGraph:
    """
    Builds a Directed Acyclic Graph (DAG) to define the execution order of formulas.
    
    This function analyzes the JSON object generated by formula_parser.py and extracts the
    dependencies of each formula, creating a directed graph where nodes are formulas
    and edges represent dependencies between them.
    
    Args:
        json_data: String containing JSON data in extracted_formulas.json format
                  or already loaded list with the corresponding structure
        
    Returns:
        A networkx DiGraph object representing the formula DAG
    """
    logger.info("Building formula DAG from input data")
    
    # Load JSON data if string is provided
    if isinstance(json_data, str):
        logger.debug("Converting JSON string to Python object")
        data = json.loads(json_data)
    else:
        data = json_data
    
    # Create a directed graph
    G = nx.DiGraph()
    
    # Dictionary to map paths to formula nodes
    formula_map = {}
    
    # First pass: Add all formula nodes to the graph
    logger.debug("First pass: Adding formula nodes to the graph")
    node_count = 0
    for group in data:
        group_path = group.get("path", "unknown")
        formula_count = len(group.get("formulas", []))
        logger.debug(f"Processing group '{group_path}' with {formula_count} formulas")
        
        for formula in group.get("formulas", []):
            formula_path = formula.get("path")
            if formula_path:
                # Add the formula node to the graph
                G.add_node(formula_path, formula=formula)
                formula_map[formula_path] = formula
                node_count += 1
    
    logger.info(f"Added {node_count} formula nodes to the graph")
    
    # Second pass: Add edges (dependencies) between formulas
    logger.debug("Second pass: Adding dependency edges between formulas")
    edge_count = 0
    for group in data:
        for formula in group.get("formulas", []):
            formula_path = formula.get("path")
            if not formula_path:
                continue
                
            # Read DAG paths from the parsed property
            if "parsed" in formula and "dag_paths" in formula["parsed"]:
                dag_paths = formula["parsed"]["dag_paths"]
                logger.debug(f"Formula '{formula_path}' has {len(dag_paths)} dependencies")
                
                for dep_path in dag_paths:
                    # Check if dependency path is a formula (not a primitive field)
                    # and not the formula path itself (self-reference)
                    if dep_path in formula_map and dep_path != formula_path:
                        # Add an edge from the dependency to this formula
                        # The direction of the edge is from the dependency to the current formula
                        # because the dependency needs to be calculated first
                        logger.debug(f"Adding dependency edge: {dep_path} -> {formula_path}")
                        G.add_edge(dep_path, formula_path)
                        edge_count += 1
    
    logger.info(f"Added {edge_count} dependency edges to the graph")
    
    # Check and remove simple self-reference cycles
    self_loops = list(nx.selfloop_edges(G))
    if self_loops:
        G.remove_edges_from(self_loops)
        logger.warning(f"Removed {len(self_loops)} self-references: {self_loops}")
    
    # Check if there are still cycles in the graph
    if not nx.is_directed_acyclic_graph(G):
        cycles = list(nx.simple_cycles(G))
        # Try to resolve cycles by removing the most problematic edge of each cycle
        if cycles:
            logger.warning(f"Detected {len(cycles)} cycles in the graph. Attempting to resolve...")
            edges_to_remove = []
            for cycle in cycles:
                if len(cycle) > 1:  # Cycle with more than one node
                    # Choose the edge with the lowest weight (a more sophisticated logic could be implemented here)
                    edge_to_remove = (cycle[-1], cycle[0])  # Last edge of the cycle
                    edges_to_remove.append(edge_to_remove)
                    logger.warning(f"Removing edge {edge_to_remove} to break cycle {cycle}")
            
            G.remove_edges_from(edges_to_remove)
            logger.info(f"Removed {len(edges_to_remove)} edges to break cycles")
            
            # Check again if the graph is a DAG
            if not nx.is_directed_acyclic_graph(G):
                remaining_cycles = list(nx.simple_cycles(G))
                logger.error(f"Could not resolve all cycles. Remaining cycles: {remaining_cycles}")
                raise ValueError(f"Could not resolve all cycles. Remaining cycles: {remaining_cycles}")
    
    logger.info("Successfully built formula DAG")
    return G

def get_execution_order(dag: nx.DiGraph) -> List[str]:
    """
    Returns the execution order of formulas based on the DAG.
    
    Args:
        dag: The directed acyclic graph of formulas
        
    Returns:
        List of formula paths in the order they should be executed
    """
    logger.info("Determining formula execution order from DAG")
    
    # Use topological sorting algorithm to determine execution order
    try:
        # Reversed topological sort orders nodes so that for each edge (u,v),
        # u comes before v in the ordering. Since our edges point from dependencies to
        # dependents, we need to reverse the order for correct execution.
        execution_order = list(reversed(list(nx.topological_sort(dag))))
        logger.info(f"Successfully determined execution order for {len(execution_order)} formulas")
        logger.debug(f"Execution order: {execution_order}")
        return execution_order
    except nx.NetworkXUnfeasible:
        # This should only happen if the graph is not a DAG (we already checked in build_formula_dag)
        logger.error("Could not determine execution order due to cycles in the graph")
        raise ValueError("Could not determine execution order due to cycles in the graph")

def load_formulas_from_file(file_path: str) -> nx.DiGraph:
    """
    Loads formulas from a JSON file and builds the DAG.
    
    Args:
        file_path: Path to the JSON file in extracted_formulas.json format
        
    Returns:
        A networkx DiGraph object representing the formula DAG
    """
    logger.info(f"Loading formulas from file: {file_path}")
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            data = json.load(f)
        
        logger.info(f"Successfully loaded data from {file_path}")
        return build_formula_dag(data)
    except FileNotFoundError:
        logger.error(f"File not found: {file_path}")
        raise
    except json.JSONDecodeError:
        logger.error(f"Invalid JSON in file: {file_path}")
        raise
    except Exception as e:
        logger.error(f"Error loading formulas from file: {e}")
        raise

def get_ordered_formulas(json_data: Union[str, List]) -> List[Dict]:
    """
    Returns the original list of formulas, already ordered for execution.
    
    This function returns the complete structure of the input JSON, but with formulas
    reordered within each group according to their dependencies. The group structure
    is preserved, only the order of formulas within each group is changed.
    
    Args:
        json_data: String containing JSON data in extracted_formulas.json format
                  or already loaded list with the corresponding structure
        
    Returns:
        List of formulas in execution order, preserving the original JSON structure
    """
    logger.info("Ordering formulas based on dependencies")
    
    # Load JSON data if string is provided
    if isinstance(json_data, str):
        logger.debug("Converting JSON string to Python object")
        data = json.loads(json_data)
    else:
        data = json_data
        
    # Create the DAG
    logger.debug("Building formula DAG")
    dag = build_formula_dag(data)
    
    # Get the execution order
    logger.debug("Getting execution order")
    execution_order = get_execution_order(dag)
    
    # Mapping of path to complete formulas
    formula_dict = {}
    group_dict = {}
    
    # Create mappings of all formulas and their groups
    logger.debug("Creating formula mappings")
    for group_idx, group in enumerate(data):
        group_path = group.get("path", "unknown")
        formula_count = len(group.get("formulas", []))
        logger.debug(f"Processing group '{group_path}' with {formula_count} formulas")
        
        for formula in group.get("formulas", []):
            formula_path = formula.get("path")
            if formula_path:
                # Create a deep copy of the formula to avoid unwanted modifications
                formula_dict[formula_path] = formula
                group_dict[formula_path] = group_idx
    
    # Reorder formulas within each group
    logger.debug("Reordering formulas within groups")
    result = [group.copy() for group in data]  # Copy the original structure
    
    for group_idx, group in enumerate(result):
        # Clear the formula list
        group["formulas"] = []
    
    # Add formulas in the correct order to their respective groups
    ordered_count = 0
    for formula_path in execution_order:
        if formula_path in formula_dict:
            formula = formula_dict[formula_path]
            group_idx = group_dict[formula_path]
            result[group_idx]["formulas"].append(formula)
            ordered_count += 1
    
    logger.info(f"Successfully ordered {ordered_count} formulas for execution")
    return result

if __name__ == "__main__":
    # Example usage
    import sys
    
    # Set up logging for console output
    logger.setLevel(logging.INFO)
    console_handler = logging.StreamHandler()
    console_handler.setFormatter(logging.Formatter('%(levelname)s - %(message)s'))
    logger.addHandler(console_handler)
    
    #if len(sys.argv) > 1:
    if True:
        file_path = "/Users/igordanielgabardogoncalves/Library/CloudStorage/OneDrive-Pessoal/GitHub/hierarquical_engine/tree_data.json"
        try:
            # Build the DAG
            logger.info(f"Processing file: {file_path}")
            dag = load_formulas_from_file(file_path)
            print(f"DAG successfully built. Nodes: {len(dag.nodes)}, Edges: {len(dag.edges)}")
            
            # Additional graph information
            print("\nGraph information:")
            roots = [n for n in dag.nodes() if dag.in_degree(n) == 0]
            leaves = [n for n in dag.nodes() if dag.out_degree(n) == 0]
            print(f"- Root nodes (no dependencies): {roots}")
            print(f"- Leaf nodes (no dependents): {leaves}")
            
            # Execution order
            print("\nExecution order:")
            execution_order = get_execution_order(dag)
            for i, formula_path in enumerate(execution_order):
                deps = list(dag.predecessors(formula_path))
                print(f"{i+1}. {formula_path} (Dependencies: {deps})")
            
            # Get ordered formulas
            logger.info("Creating ordered output files")
            with open(file_path, 'r', encoding='utf-8') as f:
                data = json.load(f)
            ordered_formulas = get_ordered_formulas(data)
            
            # Save to a new JSON file for demonstration
            output_file = file_path.rsplit('.', 1)[0] + "_ordered.json"
            with open(output_file, 'w', encoding='utf-8') as f:
                json.dump(ordered_formulas, f, indent=4, ensure_ascii=False)
            
            print(f"\nJSON with ordered formulas saved to: {output_file}")
            
            # Create a simplified representation showing only formulas in the correct order
            logger.info("Creating simplified execution order representation")
            simple_order = []
            for formula_path in execution_order:
                node_data = dag.nodes[formula_path]
                formula = node_data.get('formula', {})
                simple_formula = {
                    "path": formula_path,
                    "value": formula.get('value', ''),
                    "dependencies": list(dag.predecessors(formula_path))
                }
                # Extract base formulas from parsed object
                if "parsed" in formula and "aggr" in formula["parsed"]:
                    aggr_list = formula["parsed"].get("aggr", [])
                    if aggr_list:
                        base_formulas = [aggr.get("base", "") for aggr in aggr_list if "base" in aggr]
                        if base_formulas:
                            simple_formula["base_formulas"] = base_formulas
                
                simple_order.append(simple_formula)
            
            # Save the simplified version
            simple_output_file = file_path.rsplit('.', 1)[0] + "_execution_order.json"
            with open(simple_output_file, 'w', encoding='utf-8') as f:
                json.dump(simple_order, f, indent=4, ensure_ascii=False)
            
            logger.info(f"Created simplified execution order file: {simple_output_file}")
            print(f"Simplified execution order saved to: {simple_output_file}")
            
        except Exception as e:
            logger.error(f"Error building DAG: {e}", exc_info=True)
            print(f"Error building DAG: {e}")
    else:
        print("Usage: python formulas_dag.py <path_to_json>")